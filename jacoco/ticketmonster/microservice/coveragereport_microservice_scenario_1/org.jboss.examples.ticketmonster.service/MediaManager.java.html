<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>MediaManager.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">ticketmonster Coverage Report microservice Scenario 1</a> &gt; <a href="index.source.html" class="el_package">org.jboss.examples.ticketmonster.service</a> &gt; <span class="el_source">MediaManager.java</span></div><h1>MediaManager.java</h1><pre class="source lang-java linenums">package org.jboss.examples.ticketmonster.service;

import static org.jboss.examples.ticketmonster.model.MediaType.IMAGE;

import java.io.BufferedInputStream;
import java.io.BufferedOutputStream;
import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.OutputStream;
import java.net.HttpURLConnection;
import java.net.MalformedURLException;
import java.net.URL;
import java.net.URLConnection;
import java.util.HashMap;
import java.util.Map;

import javax.enterprise.context.RequestScoped;

import org.jboss.examples.ticketmonster.model.MediaItem;
import org.jboss.examples.ticketmonster.model.MediaType;
import org.jboss.examples.ticketmonster.util.Base64;
import org.jboss.examples.ticketmonster.util.Reflections;

/**
 * &lt;p&gt;
 * The media manager is responsible for taking a media item, and returning either the URL of the cached version (if the
 * application cannot load the item from the URL), or the original URL.
 * &lt;/p&gt;
 * 
 * &lt;p&gt;
 * The media manager also transparently caches the media items on first load.
 * &lt;/p&gt;
 * 
 * &lt;p&gt;
 * The computed URLs are cached for the duration of a request. This provides a good balance between consuming heap space, and
 * computational time.
 * &lt;/p&gt;
 * 
 * @author Pete Muir
 * 
 */
@RequestScoped
public class MediaManager {

    /**
     * Locate the tmp directory for the machine
     */
    private static final File tmpDir;

    static {
<span class="fc" id="L54">        String dataDir = System.getenv(&quot;OPENSHIFT_DATA_DIR&quot;);</span>
<span class="pc bpc" id="L55" title="1 of 2 branches missed.">        String parentDir = dataDir != null ? dataDir : System.getProperty(&quot;java.io.tmpdir&quot;);</span>
<span class="fc" id="L56">        tmpDir = new File(parentDir, &quot;org.jboss.jdf.examples.ticket-monster&quot;);</span>
<span class="pc bpc" id="L57" title="1 of 2 branches missed.">        if (tmpDir.exists()) {</span>
<span class="nc bnc" id="L58" title="All 2 branches missed.">            if (tmpDir.isFile())</span>
<span class="nc" id="L59">                throw new IllegalStateException(tmpDir.getAbsolutePath() + &quot; already exists, and is a file. Remove it.&quot;);</span>
        } else {
<span class="fc" id="L61">            tmpDir.mkdir();</span>
        }
<span class="fc" id="L63">    }</span>

    /**
     * A request scoped cache of computed URLs of media items.
     */
    private final Map&lt;MediaItem, MediaPath&gt; cache;

<span class="fc" id="L70">    public MediaManager() {</span>

<span class="fc" id="L72">        this.cache = new HashMap&lt;MediaItem, MediaPath&gt;();</span>
<span class="fc" id="L73">    }</span>

    /**
     * Load a cached file by name
     * 
     * @param fileName
     * @return
     */
    public File getCachedFile(String fileName) {
<span class="fc" id="L82">        return new File(tmpDir, fileName);</span>
    }

    /**
     * Obtain the URL of the media item. If the URL h has already been computed in this request, it will be looked up in the
     * request scoped cache, otherwise it will be computed, and placed in the request scoped cache.
     */
    public MediaPath getPath(MediaItem mediaItem) {
<span class="pc bpc" id="L90" title="1 of 2 branches missed.">        if (cache.containsKey(mediaItem)) {</span>
<span class="nc" id="L91">            return cache.get(mediaItem);</span>
        } else {
<span class="fc" id="L93">            MediaPath mediaPath = createPath(mediaItem);</span>
<span class="fc" id="L94">            cache.put(mediaItem, mediaPath);</span>
<span class="fc" id="L95">            return mediaPath;</span>
        }
    }

    /**
     * Compute the URL to a media item. If the media item is not cacheable, then, as long as the resource can be loaded, the
     * original URL is returned. If the resource is not available, then a placeholder image replaces it. If the media item is
     * cachable, it is first cached in the tmp directory, and then path to load it is returned.
     */
    private MediaPath createPath(MediaItem mediaItem) {
<span class="pc bpc" id="L105" title="1 of 2 branches missed.">    	if(mediaItem == null) {</span>
<span class="nc" id="L106">    		return createCachedMedia(Reflections.getResource(&quot;not_available.jpg&quot;).toExternalForm(), IMAGE);</span>
<span class="pc bpc" id="L107" title="1 of 2 branches missed.">    	} else if (!mediaItem.getMediaType().isCacheable()) {</span>
<span class="nc bnc" id="L108" title="All 2 branches missed.">            if (checkResourceAvailable(mediaItem)) {</span>
<span class="nc" id="L109">                return new MediaPath(mediaItem.getUrl(), false, mediaItem.getMediaType());</span>
            } else {
<span class="nc" id="L111">                return createCachedMedia(Reflections.getResource(&quot;not_available.jpg&quot;).toExternalForm(), IMAGE);</span>
            }
        } else {
<span class="fc" id="L114">            return createCachedMedia(mediaItem);</span>
        }
    }

    /**
     * Check if a media item can be loaded from it's URL, using the JDK URLConnection classes.
     */
    private boolean checkResourceAvailable(MediaItem mediaItem) {
<span class="nc" id="L122">        URL url = null;</span>
        try {
<span class="nc" id="L124">            url = new URL(mediaItem.getUrl());</span>
<span class="nc" id="L125">        } catch (MalformedURLException e) {</span>
<span class="nc" id="L126">        }</span>

<span class="nc bnc" id="L128" title="All 2 branches missed.">        if (url != null) {</span>
            try {
<span class="nc" id="L130">                URLConnection connection = url.openConnection();</span>
<span class="nc bnc" id="L131" title="All 2 branches missed.">                if (connection instanceof HttpURLConnection) {</span>
<span class="nc bnc" id="L132" title="All 2 branches missed.">                    return ((HttpURLConnection) connection).getResponseCode() == HttpURLConnection.HTTP_OK;</span>
                } else {
<span class="nc bnc" id="L134" title="All 2 branches missed.">                    return connection.getContentLength() &gt; 0;</span>
                }
<span class="nc" id="L136">            } catch (IOException e) {</span>
            }
        }
<span class="nc" id="L139">        return false;</span>
    }

    /**
     * The cached file name is a base64 encoded version of the URL. This means we don't need to maintain a database of cached
     * files.
     */
    private String getCachedFileName(String url) {
<span class="fc" id="L147">        return Base64.encodeToString(url.getBytes(), false);</span>
    }

    /**
     * Check to see if the file is already cached.
     */
    private boolean alreadyCached(String cachedFileName) {
<span class="fc" id="L154">        File cache = getCachedFile(cachedFileName);</span>
<span class="pc bpc" id="L155" title="1 of 2 branches missed.">        if (cache.exists()) {</span>
<span class="nc bnc" id="L156" title="All 2 branches missed.">            if (cache.isDirectory()) {</span>
<span class="nc" id="L157">                throw new IllegalStateException(cache.getAbsolutePath() + &quot; already exists, and is a directory. Remove it.&quot;);</span>
            }
<span class="nc" id="L159">            return true;</span>
        } else {
<span class="fc" id="L161">            return false;</span>
        }
    }

    /**
     * To cache a media item we first load it from the net, then write it to disk.
     */
    private MediaPath createCachedMedia(String url, MediaType mediaType) {
<span class="fc" id="L169">        String cachedFileName = getCachedFileName(url);</span>
<span class="pc bpc" id="L170" title="1 of 2 branches missed.">        if (!alreadyCached(cachedFileName)) {</span>
<span class="fc" id="L171">            URL _url = null;</span>
            try {
<span class="fc" id="L173">                _url = new URL(url);</span>
<span class="nc" id="L174">            } catch (MalformedURLException e) {</span>
<span class="nc" id="L175">                throw new IllegalStateException(&quot;Error reading URL &quot; + url);</span>
<span class="fc" id="L176">            }</span>

            try {
<span class="fc" id="L179">                InputStream is = null;</span>
<span class="fc" id="L180">                OutputStream os = null;</span>
                try {
<span class="fc" id="L182">                    is = new BufferedInputStream(_url.openStream());</span>
<span class="fc" id="L183">                    os = new BufferedOutputStream(getCachedOutputStream(cachedFileName));</span>
                    while (true) {
<span class="fc" id="L185">                        int data = is.read();</span>
<span class="fc bfc" id="L186" title="All 2 branches covered.">                        if (data == -1)</span>
<span class="fc" id="L187">                            break;</span>
<span class="fc" id="L188">                        os.write(data);</span>
<span class="fc" id="L189">                    }</span>
                } finally {
<span class="fc bfc" id="L191" title="All 2 branches covered.">                    if (is != null)</span>
<span class="fc" id="L192">                        is.close();</span>
<span class="fc bfc" id="L193" title="All 2 branches covered.">                    if (os != null)</span>
<span class="fc" id="L194">                        os.close();</span>
                }
<span class="fc" id="L196">            } catch (IOException e) {</span>
<span class="fc" id="L197">                throw new IllegalStateException(&quot;Error caching &quot; + mediaType.getDescription(), e);</span>
<span class="fc" id="L198">            }</span>
        }
<span class="fc" id="L200">        return new MediaPath(cachedFileName, true, mediaType);</span>
    }

    private MediaPath createCachedMedia(MediaItem mediaItem) {
<span class="fc" id="L204">        return createCachedMedia(mediaItem.getUrl(), mediaItem.getMediaType());</span>
    }

    private OutputStream getCachedOutputStream(String fileName) {
        try {
<span class="fc" id="L209">            return new FileOutputStream(getCachedFile(fileName));</span>
<span class="nc" id="L210">        } catch (FileNotFoundException e) {</span>
<span class="nc" id="L211">            throw new IllegalStateException(&quot;Error creating cached file&quot;, e);</span>
        }
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.7.202105040129</span></div></body></html>