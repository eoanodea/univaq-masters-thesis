<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>SectionAllocation.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">ticketmonster Coverage Report microservice Scenario 3</a> &gt; <a href="index.source.html" class="el_package">org.ticketmonster.orders.domain</a> &gt; <span class="el_source">SectionAllocation.java</span></div><h1>SectionAllocation.java</h1><pre class="source lang-java linenums">package org.ticketmonster.orders.domain;


import org.teiid.spring.annotations.InsertQuery;
import org.teiid.spring.annotations.SelectQuery;
import org.teiid.spring.annotations.UpdateQuery;

import static javax.persistence.GenerationType.IDENTITY;
import static javax.persistence.GenerationType.TABLE;

import java.io.Serializable;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

import javax.persistence.*;
import javax.validation.constraints.NotNull;

/**
 * &lt;p&gt;
 * Represents the state of ticket allocation in a section, for a specific performanceId.
 * &lt;/p&gt;
 * 
 * &lt;p&gt;
 * Optimistic locking ensures that two tickets will not be sold within the same row. Adding a member annotated with
 * &lt;code&gt;@Version&lt;/code&gt; enables optimistic locking.
 * &lt;/p&gt;
 * 
 * &lt;p&gt;
 * The performanceId and section form the natural id of this entity, and therefore must be unique. JPA requires us to use the
 * class level &lt;code&gt;@Table&lt;/code&gt; constraint.
 * &lt;/p&gt;
 * 
 * @author Marius Bogoevici
 * @author Pete Muir
 */
@SelectQuery(&quot;SELECT sa.id, sa.allocated, sa.occupiedCount AS occupied_count, sa.performance_id, e.name as performance_name, sa.version, sa.section_id &quot; +
        &quot;FROM legacyDS.SectionAllocation sa &quot; +
        &quot;JOIN legacyDS.Performance p ON sa.performance_id=p.id &quot; +
        &quot;JOIN legacyDS.Appearance s ON p.show_id=s.id &quot; +
        &quot;JOIN legacyDS.Event e ON s.event_id=e.id;&quot;)
@InsertQuery(&quot;FOR EACH ROW \n&quot;+
        &quot;BEGIN ATOMIC \n&quot; +
        &quot;INSERT INTO legacyDS.SectionAllocation (id, allocated, occupiedCount, version, performance_id, section_id) values (NEW.id, NEW.allocated, NEW.occupied_count, NEW.version, NEW.performance_id, NEW.section_id);\n&quot; +
        &quot;END&quot;)
@UpdateQuery(&quot;FOR EACH ROW \n&quot; +
        &quot;BEGIN ATOMIC \n &quot; +
        &quot;UPDATE legacyDS.SectionAllocation SET version=NEW.version, allocated=NEW.allocated, occupiedCount=NEW.occupied_count WHERE id=OLD.id;&quot; +
        &quot;END&quot;)
@Entity
@Table(name=&quot;section_allocation&quot;, uniqueConstraints = @UniqueConstraint(columnNames = { &quot;performance_id&quot;, &quot;section_id&quot; }))
public class SectionAllocation implements Serializable {
    @Transient
    private static final int EXPIRATION_TIME = 60 * 1000;

    /* Declaration of fields */

    @TableGenerator(name = &quot;section_allocation&quot;,
            table = &quot;id_generator&quot;,
            pkColumnName = &quot;idKey&quot;,
            valueColumnName = &quot;idvalue&quot;,
            pkColumnValue = &quot;section_allocation&quot;,
            allocationSize = 1)
    @Id
    @GeneratedValue(strategy = TABLE, generator = &quot;section_allocation&quot;)
    private Long id;

    /**
     * &lt;p&gt;
     * The version used to optimistically lock this entity.
     * &lt;/p&gt;
     * 
     * &lt;p&gt;
     * Adding this field enables optimistic locking. As we don't access this field in the application, we need to suppress the
     * warnings the java compiler gives us about not using the field!
     * &lt;/p&gt;
     */
    @SuppressWarnings(&quot;unused&quot;)
    @Version
    private long version;

    /**
     * &lt;p&gt;
     * The performanceId to which this allocation relates. The &lt;code&gt;@ManyToOne&lt;code&gt; JPA mapping establishes this relationship.
     * &lt;/p&gt;
     * 
     * &lt;p&gt;
     * The performanceId must be specified, so we add the Bean Validation constrain &lt;code&gt;@NotNull&lt;/code&gt;
     * &lt;/p&gt;
     */
    @NotNull
    @Embedded
    private PerformanceId performanceId;

    /**
     * &lt;p&gt;
     * The section to which this allocation relates. The &lt;code&gt;@ManyToOne&lt;code&gt; JPA mapping establishes this relationship.
     * &lt;/p&gt;
     * 
     * &lt;p&gt;
     * The section must be specified, so we add the Bean Validation constrain &lt;code&gt;@NotNull&lt;/code&gt;
     * &lt;/p&gt;
     */
    @ManyToOne
    @NotNull
    private Section section;

    /**
     * &lt;p&gt;
     * A two dimensional matrix of allocated seats in a section, represented by a 2 dimensional array.
     * &lt;/p&gt;
     * 
     * &lt;p&gt;
     * A two dimensional array doesn't have a natural RDBMS mapping, so we simply store this a binary object in the database, an
     * approach which requires no additional mapping logic. Any analysis of which seats within a section are allocated is done
     * in the business logic, below, not by the RDBMS.
     * &lt;/p&gt;
     * 
     * &lt;p&gt;
     * &lt;code&gt;@Lob&lt;/code&gt; instructs JPA to map this a large object in the database
     * &lt;/p&gt;
     */
    @Lob
    private long[][] allocated;

    /**
     * &lt;p&gt;
     *     The number of occupied seats in a section. It is updated whenever tickets are sold or canceled.
     * &lt;/p&gt;
     *
     * &lt;p&gt;
     *     This field contains a summary of the information found in the &lt;code&gt;allocated&lt;/code&gt; fields, and
     *     it is intended to be used for analytics purposes only.
     * &lt;/p&gt;
     */
<span class="nc" id="L136">    @Column(name = &quot;occupied_count&quot;)</span>
    private int occupiedCount = 0;

    /**
     * Constructor for persistence
     */
<span class="nc" id="L142">    public SectionAllocation() {</span>
<span class="nc" id="L143">    }</span>

<span class="nc" id="L145">    public SectionAllocation(PerformanceId performanceId, Section section) {</span>
<span class="nc" id="L146">        this.performanceId = performanceId;</span>
<span class="nc" id="L147">        this.section = section;</span>
<span class="nc" id="L148">        this.allocated = new long[section.getNumberOfRows()][section.getRowCapacity()];</span>
<span class="nc bnc" id="L149" title="All 2 branches missed.">        for (long[] seatStates : (long[][])allocated) {</span>
<span class="nc" id="L150">            Arrays.fill(seatStates, 0l);</span>
        }
<span class="nc" id="L152">    }</span>

    /**
     * Post-load callback method initializes the allocation table if it not populated already
     * for the entity
     */
    @PostLoad
    void initialize() {
<span class="nc bnc" id="L160" title="All 2 branches missed.">    	if (this.allocated == null) {</span>
<span class="nc" id="L161">    		this.allocated = new long[this.section.getNumberOfRows()][this.section.getRowCapacity()];</span>
<span class="nc bnc" id="L162" title="All 2 branches missed.">            for (long[] seatStates : allocated) {</span>
<span class="nc" id="L163">                Arrays.fill(seatStates, 0l);</span>
            }
        }
<span class="nc" id="L166">    }</span>

    /**
     * Check if a particular seat is allocated in this section for this performance.
     * 
     * @return true if the seat is allocated, otherwise false
     */
    public boolean isAllocated(Seat s) {
        // Examine the allocation matrix, using the row and seat number as indices
<span class="nc bnc" id="L175" title="All 2 branches missed.">        return allocated[s.getRowNumber() - 1][s.getNumber() - 1] != 0;</span>
    }

    /**
     * Allocate the specified number seats within this section for this performance. Optionally allocate them in a contiguous
     * block.
     * 
     * @param seatCount the number of seats to allocate
     * @param contiguous whether the seats must be allocated in a contiguous block or not
     * @return the allocated seats
     */
    public ArrayList&lt;Seat&gt; allocateSeats(int seatCount, boolean contiguous) {
        // The list of seats allocated
<span class="nc" id="L188">        ArrayList&lt;Seat&gt; seats = new ArrayList&lt;Seat&gt;();</span>

        // The seat allocation algorithm starts by iterating through the rows in this section
<span class="nc bnc" id="L191" title="All 2 branches missed.">        for (int rowCounter = 0; rowCounter &lt; section.getNumberOfRows(); rowCounter++) {</span>

<span class="nc bnc" id="L193" title="All 2 branches missed.">            if (contiguous) {</span>
                // identify the first block of free seats of the requested size
<span class="nc" id="L195">                int startSeat = findFreeGapStart(rowCounter, 0, seatCount);</span>
                // if a large enough block of seats is available
<span class="nc bnc" id="L197" title="All 2 branches missed.">                if (startSeat &gt;= 0) {</span>
                    // Create the list of allocated seats to return
<span class="nc bnc" id="L199" title="All 2 branches missed.">                    for (int i = 1; i &lt;= seatCount; i++) {</span>
<span class="nc" id="L200">                        seats.add(new Seat(section, rowCounter + 1, startSeat + i));</span>
                    }
                    // Seats are allocated now, so we can stop checking rows
<span class="nc" id="L203">                    break;</span>
                }
<span class="nc" id="L205">            } else {</span>
                // As we aren't allocating contiguously, allocate each seat needed, one at a time
<span class="nc" id="L207">                int startSeat = findFreeGapStart(rowCounter, 0, 1);</span>
                // if a seat is found
<span class="nc bnc" id="L209" title="All 2 branches missed.">                if (startSeat &gt;= 0) {</span>
                    do {
                        // Create the seat to return to the user
<span class="nc" id="L212">                        seats.add(new Seat(section, rowCounter + 1, startSeat + 1));</span>
                        // Find the next free seat in the row
<span class="nc" id="L214">                        startSeat = findFreeGapStart(rowCounter, startSeat, 1);</span>
<span class="nc bnc" id="L215" title="All 4 branches missed.">                    } while (startSeat &gt;= 0 &amp;&amp; seats.size() &lt; seatCount);</span>
<span class="nc bnc" id="L216" title="All 2 branches missed.">                    if (seats.size() == seatCount) {</span>
<span class="nc" id="L217">                        break;</span>
                    }
                }
            }
        }
        // Simple check to make sure we could actually allocate the required number of seats

<span class="nc bnc" id="L224" title="All 2 branches missed.">        if (seats.size() == seatCount) {</span>
<span class="nc bnc" id="L225" title="All 2 branches missed.">            for (Seat seat : seats) {</span>
<span class="nc" id="L226">                allocate(seat.getRowNumber() - 1, seat.getNumber() - 1, 1, expirationTimestamp());</span>
<span class="nc" id="L227">            }</span>
<span class="nc" id="L228">            return seats;</span>
        } else {
<span class="nc" id="L230">            return new ArrayList&lt;Seat&gt;(0);</span>
        }
    }

    public void markOccupied(List&lt;Seat&gt; seats) {
<span class="nc bnc" id="L235" title="All 2 branches missed.">        for (Seat seat : seats) {</span>
<span class="nc" id="L236">            allocate(seat.getRowNumber() - 1, seat.getNumber() - 1, 1, -1);</span>
<span class="nc" id="L237">        }</span>
<span class="nc" id="L238">    }</span>

    /**
     * Helper method which can locate blocks of seats
     * 
     * @param row The row number to check
     * @param startSeat The seat to start with in the row
     * @param size The size of the block to locate
     * @return
     */
    private int findFreeGapStart(int row, int startSeat, int size) {

        // An array of occupied seats in the row
<span class="nc" id="L251">        long[] occupied = allocated[row];</span>
<span class="nc" id="L252">        int candidateStart = -1;</span>

        // Iterate over the seats, and locate the first free seat block
<span class="nc bnc" id="L255" title="All 2 branches missed.">        for (int i = startSeat; i &lt; occupied.length; i++) {</span>
            // if the seat isn't allocated
<span class="nc" id="L257">            long currentTimestamp = System.currentTimeMillis();</span>
<span class="nc bnc" id="L258" title="All 4 branches missed.">            if (occupied[i] &gt;=0 &amp;&amp; currentTimestamp &gt; occupied[i]) {</span>
                // then set this as a possible start
<span class="nc bnc" id="L260" title="All 2 branches missed.">                if (candidateStart == -1) {</span>
<span class="nc" id="L261">                    candidateStart = i;</span>
                }
                // if we've counted out enough seats since the possible start, then we are done
<span class="nc bnc" id="L264" title="All 2 branches missed.">                if ((size == (i - candidateStart + 1))) {</span>
<span class="nc" id="L265">                    return candidateStart;</span>
                }
            } else {
<span class="nc" id="L268">                candidateStart = -1;</span>
            }
        }
<span class="nc" id="L271">        return -1;</span>
    }

    /**
     * Helper method to allocate a specific block of seats
     * 
     * @param row the row in which the seat should be allocated
     * @param start the seat number to start allocating from
     * @param size the size of the block to allocate
     * @throws SeatAllocationException if less than 1 seat is to be allocated
     * @throws SeatAllocationException if the first seat to allocate is more than the number of seats in the row
     * @throws SeatAllocationException if the last seat to allocate is more than the number of seats in the row
     * @throws SeatAllocationException if the seats are already occupied.
     */
    private void allocate(int row, int start, int size, long finalState) throws SeatAllocationException {
<span class="nc" id="L286">        long[] occupied = allocated[row];</span>
<span class="nc bnc" id="L287" title="All 2 branches missed.">        if (size &lt;= 0) {</span>
<span class="nc" id="L288">            throw new SeatAllocationException(&quot;Number of seats must be greater than zero&quot;);</span>
        }
<span class="nc bnc" id="L290" title="All 4 branches missed.">        if (start &lt; 0 || start &gt;= occupied.length) {</span>
<span class="nc" id="L291">            throw new SeatAllocationException(&quot;Seat number must be betwen 1 and &quot; + occupied.length);</span>
        }
<span class="nc bnc" id="L293" title="All 2 branches missed.">        if ((start + size) &gt; occupied.length) {</span>
<span class="nc" id="L294">            throw new SeatAllocationException(&quot;Cannot allocate seats above row capacity&quot;);</span>
        }

        // Now that we know we can allocate the seats, set them to occupied in the allocation matrix
<span class="nc bnc" id="L298" title="All 2 branches missed.">        for (int i = start; i &lt; (start + size); i++) {</span>
<span class="nc" id="L299">            occupied[i] = finalState;</span>
<span class="nc" id="L300">            occupiedCount++;</span>
        }

<span class="nc" id="L303">    }</span>

    /**
     * Dellocate a seat within this section for this performance.
     *
     * @param seat the seats that need to be deallocated
     */
    public void deallocate(Seat seat) {
<span class="nc bnc" id="L311" title="All 2 branches missed.">        if (!isAllocated(seat)) {</span>
<span class="nc" id="L312">            throw new SeatAllocationException(&quot;Trying to deallocate an unallocated seat!&quot;);</span>
        }
<span class="nc" id="L314">        this.allocated[seat.getRowNumber()-1][seat.getNumber()-1] = 0;</span>
<span class="nc" id="L315">        occupiedCount --;</span>
<span class="nc" id="L316">    }</span>

    /* Boilerplate getters and setters */

    public int getOccupiedCount() {
<span class="nc" id="L321">        return occupiedCount;</span>
    }

    public PerformanceId getPerformanceId() {
<span class="nc" id="L325">        return performanceId;</span>
    }

    public Section getSection() {
<span class="nc" id="L329">        return section;</span>
    }

    public Long getId() {
<span class="nc" id="L333">        return id;</span>
    }

    private long expirationTimestamp() {
<span class="nc" id="L337">        return System.currentTimeMillis() + EXPIRATION_TIME;</span>
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.7.202105040129</span></div></body></html>