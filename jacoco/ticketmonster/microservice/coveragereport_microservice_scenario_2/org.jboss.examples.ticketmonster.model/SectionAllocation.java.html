<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>SectionAllocation.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">ticketmonster Coverage Report microservice Scenario 2</a> &gt; <a href="index.source.html" class="el_package">org.jboss.examples.ticketmonster.model</a> &gt; <span class="el_source">SectionAllocation.java</span></div><h1>SectionAllocation.java</h1><pre class="source lang-java linenums">package org.jboss.examples.ticketmonster.model;


import static javax.persistence.GenerationType.IDENTITY;

import java.io.Serializable;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

import javax.persistence.Entity;
import javax.persistence.GeneratedValue;
import javax.persistence.Id;
import javax.persistence.Lob;
import javax.persistence.ManyToOne;
import javax.persistence.PostLoad;
import javax.persistence.Table;
import javax.persistence.UniqueConstraint;
import javax.persistence.Version;
import javax.validation.constraints.NotNull;

/**
 * &lt;p&gt;
 * Represents the state of ticket allocation in a section, for a specific performance.
 * &lt;/p&gt;
 * 
 * &lt;p&gt;
 * Optimistic locking ensures that two tickets will not be sold within the same row. Adding a member annotated with
 * &lt;code&gt;@Version&lt;/code&gt; enables optimistic locking.
 * &lt;/p&gt;
 * 
 * &lt;p&gt;
 * The performance and section form the natural id of this entity, and therefore must be unique. JPA requires us to use the
 * class level &lt;code&gt;@Table&lt;/code&gt; constraint.
 * &lt;/p&gt;
 * 
 * @author Marius Bogoevici
 * @author Pete Muir
 */
@Entity
@Table(uniqueConstraints = @UniqueConstraint(columnNames = { &quot;performance_id&quot;, &quot;section_id&quot; }))
public class SectionAllocation implements Serializable {
    public static final int EXPIRATION_TIME = 60 * 1000;

    /* Declaration of fields */

    /**
     * The synthetic id of the object.
     */
    @Id
    @GeneratedValue(strategy = IDENTITY)
    private Long id;

    /**
     * &lt;p&gt;
     * The version used to optimistically lock this entity.
     * &lt;/p&gt;
     * 
     * &lt;p&gt;
     * Adding this field enables optimistic locking. As we don't access this field in the application, we need to suppress the
     * warnings the java compiler gives us about not using the field!
     * &lt;/p&gt;
     */
    @SuppressWarnings(&quot;unused&quot;)
    @Version
    private long version;

    /**
     * &lt;p&gt;
     * The performance to which this allocation relates. The &lt;code&gt;@ManyToOne&lt;code&gt; JPA mapping establishes this relationship.
     * &lt;/p&gt;
     * 
     * &lt;p&gt;
     * The performance must be specified, so we add the Bean Validation constrain &lt;code&gt;@NotNull&lt;/code&gt;
     * &lt;/p&gt;
     */
    @ManyToOne
    @NotNull
    private Performance performance;

    /**
     * &lt;p&gt;
     * The section to which this allocation relates. The &lt;code&gt;@ManyToOne&lt;code&gt; JPA mapping establishes this relationship.
     * &lt;/p&gt;
     * 
     * &lt;p&gt;
     * The section must be specified, so we add the Bean Validation constrain &lt;code&gt;@NotNull&lt;/code&gt;
     * &lt;/p&gt;
     */
    @ManyToOne
    @NotNull
    private Section section;

    /**
     * &lt;p&gt;
     * A two dimensional matrix of allocated seats in a section, represented by a 2 dimensional array.
     * &lt;/p&gt;
     * 
     * &lt;p&gt;
     * A two dimensional array doesn't have a natural RDBMS mapping, so we simply store this a binary object in the database, an
     * approach which requires no additional mapping logic. Any analysis of which seats within a section are allocated is done
     * in the business logic, below, not by the RDBMS.
     * &lt;/p&gt;
     * 
     * &lt;p&gt;
     * &lt;code&gt;@Lob&lt;/code&gt; instructs JPA to map this a large object in the database
     * &lt;/p&gt;
     */
    @Lob
    private long[][] allocated;

    /**
     * &lt;p&gt;
     *     The number of occupied seats in a section. It is updated whenever tickets are sold or canceled.
     * &lt;/p&gt;
     *
     * &lt;p&gt;
     *     This field contains a summary of the information found in the &lt;code&gt;allocated&lt;/code&gt; fields, and
     *     it is intended to be used for analytics purposes only.
     * &lt;/p&gt;
     */
<span class="fc" id="L122">    private int occupiedCount = 0;</span>

    /**
     * Constructor for persistence
     */
<span class="fc" id="L127">    public SectionAllocation() {</span>
<span class="fc" id="L128">    }</span>

<span class="fc" id="L130">    public SectionAllocation(Performance performance, Section section) {</span>
<span class="fc" id="L131">        this.performance = performance;</span>
<span class="fc" id="L132">        this.section = section;</span>
<span class="fc" id="L133">        this.allocated = new long[section.getNumberOfRows()][section.getRowCapacity()];</span>
<span class="fc bfc" id="L134" title="All 2 branches covered.">        for (long[] seatStates : allocated) {</span>
<span class="fc" id="L135">            Arrays.fill(seatStates, 0l);</span>
        }
<span class="fc" id="L137">    }</span>

    /**
     * Post-load callback method initializes the allocation table if it not populated already
     * for the entity
     */
    @PostLoad
    void initialize() {
<span class="fc bfc" id="L145" title="All 2 branches covered.">    	if (this.allocated == null) {</span>
<span class="fc" id="L146">    		this.allocated = new long[this.section.getNumberOfRows()][this.section.getRowCapacity()];</span>
<span class="fc bfc" id="L147" title="All 2 branches covered.">            for (long[] seatStates : allocated) {</span>
<span class="fc" id="L148">                Arrays.fill(seatStates, 0l);</span>
            }
        }
<span class="fc" id="L151">    }</span>

    /**
     * Check if a particular seat is allocated in this section for this performance.
     * 
     * @return true if the seat is allocated, otherwise false
     */
    public boolean isAllocated(Seat s) {
        // Examine the allocation matrix, using the row and seat number as indices
<span class="pc bpc" id="L160" title="1 of 2 branches missed.">        return allocated[s.getRowNumber() - 1][s.getNumber() - 1] != 0;</span>
    }

    /**
     * Allocate the specified number seats within this section for this performance. Optionally allocate them in a contiguous
     * block.
     * 
     * @param seatCount the number of seats to allocate
     * @param contiguous whether the seats must be allocated in a contiguous block or not
     * @return the allocated seats
     */
    public ArrayList&lt;Seat&gt; allocateSeats(int seatCount, boolean contiguous) {
        // The list of seats allocated
<span class="fc" id="L173">        ArrayList&lt;Seat&gt; seats = new ArrayList&lt;Seat&gt;();</span>

        // The seat allocation algorithm starts by iterating through the rows in this section
<span class="pc bpc" id="L176" title="1 of 2 branches missed.">        for (int rowCounter = 0; rowCounter &lt; section.getNumberOfRows(); rowCounter++) {</span>

<span class="pc bpc" id="L178" title="1 of 2 branches missed.">            if (contiguous) {</span>
                // identify the first block of free seats of the requested size
<span class="fc" id="L180">                int startSeat = findFreeGapStart(rowCounter, 0, seatCount);</span>
                // if a large enough block of seats is available
<span class="fc bfc" id="L182" title="All 2 branches covered.">                if (startSeat &gt;= 0) {</span>
                    // Create the list of allocated seats to return
<span class="fc bfc" id="L184" title="All 2 branches covered.">                    for (int i = 1; i &lt;= seatCount; i++) {</span>
<span class="fc" id="L185">                        seats.add(new Seat(section, rowCounter + 1, startSeat + i));</span>
                    }
                    // Seats are allocated now, so we can stop checking rows
<span class="fc" id="L188">                    break;</span>
                }
<span class="fc" id="L190">            } else {</span>
                // As we aren't allocating contiguously, allocate each seat needed, one at a time
<span class="nc" id="L192">                int startSeat = findFreeGapStart(rowCounter, 0, 1);</span>
                // if a seat is found
<span class="nc bnc" id="L194" title="All 2 branches missed.">                if (startSeat &gt;= 0) {</span>
                    do {
                        // Create the seat to return to the user
<span class="nc" id="L197">                        seats.add(new Seat(section, rowCounter + 1, startSeat + 1));</span>
                        // Find the next free seat in the row
<span class="nc" id="L199">                        startSeat = findFreeGapStart(rowCounter, startSeat, 1);</span>
<span class="nc bnc" id="L200" title="All 4 branches missed.">                    } while (startSeat &gt;= 0 &amp;&amp; seats.size() &lt; seatCount);</span>
<span class="nc bnc" id="L201" title="All 2 branches missed.">                    if (seats.size() == seatCount) {</span>
<span class="nc" id="L202">                        break;</span>
                    }
                }
            }
        }
        // Simple check to make sure we could actually allocate the required number of seats

<span class="pc bpc" id="L209" title="1 of 2 branches missed.">        if (seats.size() == seatCount) {</span>
<span class="fc bfc" id="L210" title="All 2 branches covered.">            for (Seat seat : seats) {</span>
<span class="fc" id="L211">                allocate(seat.getRowNumber() - 1, seat.getNumber() - 1, 1, expirationTimestamp());</span>
<span class="fc" id="L212">            }</span>
<span class="fc" id="L213">            return seats;</span>
        } else {
<span class="nc" id="L215">            return new ArrayList&lt;Seat&gt;(0);</span>
        }
    }

    public void markOccupied(List&lt;Seat&gt; seats) {
<span class="fc bfc" id="L220" title="All 2 branches covered.">        for (Seat seat : seats) {</span>
<span class="fc" id="L221">            allocate(seat.getRowNumber() - 1, seat.getNumber() - 1, 1, -1);</span>
<span class="fc" id="L222">        }</span>
<span class="fc" id="L223">    }</span>

    /**
     * Helper method which can locate blocks of seats
     * 
     * @param row The row number to check
     * @param startSeat The seat to start with in the row
     * @param size The size of the block to locate
     * @return
     */
    private int findFreeGapStart(int row, int startSeat, int size) {

        // An array of occupied seats in the row
<span class="fc" id="L236">        long[] occupied = allocated[row];</span>
<span class="fc" id="L237">        int candidateStart = -1;</span>

        // Iterate over the seats, and locate the first free seat block
<span class="fc bfc" id="L240" title="All 2 branches covered.">        for (int i = startSeat; i &lt; occupied.length; i++) {</span>
            // if the seat isn't allocated
<span class="fc" id="L242">            long currentTimestamp = System.currentTimeMillis();</span>
<span class="pc bpc" id="L243" title="1 of 4 branches missed.">            if (occupied[i] &gt;=0 &amp;&amp; currentTimestamp &gt; occupied[i]) {</span>
                // then set this as a possible start
<span class="fc bfc" id="L245" title="All 2 branches covered.">                if (candidateStart == -1) {</span>
<span class="fc" id="L246">                    candidateStart = i;</span>
                }
                // if we've counted out enough seats since the possible start, then we are done
<span class="fc bfc" id="L249" title="All 2 branches covered.">                if ((size == (i - candidateStart + 1))) {</span>
<span class="fc" id="L250">                    return candidateStart;</span>
                }
            } else {
<span class="fc" id="L253">                candidateStart = -1;</span>
            }
        }
<span class="fc" id="L256">        return -1;</span>
    }

    /**
     * Helper method to allocate a specific block of seats
     * 
     * @param row the row in which the seat should be allocated
     * @param start the seat number to start allocating from
     * @param size the size of the block to allocate
     * @throws SeatAllocationException if less than 1 seat is to be allocated
     * @throws SeatAllocationException if the first seat to allocate is more than the number of seats in the row
     * @throws SeatAllocationException if the last seat to allocate is more than the number of seats in the row
     * @throws SeatAllocationException if the seats are already occupied.
     */
    private void allocate(int row, int start, int size, long finalState) throws SeatAllocationException {
<span class="fc" id="L271">        long[] occupied = allocated[row];</span>
<span class="pc bpc" id="L272" title="1 of 2 branches missed.">        if (size &lt;= 0) {</span>
<span class="nc" id="L273">            throw new SeatAllocationException(&quot;Number of seats must be greater than zero&quot;);</span>
        }
<span class="pc bpc" id="L275" title="2 of 4 branches missed.">        if (start &lt; 0 || start &gt;= occupied.length) {</span>
<span class="nc" id="L276">            throw new SeatAllocationException(&quot;Seat number must be betwen 1 and &quot; + occupied.length);</span>
        }
<span class="pc bpc" id="L278" title="1 of 2 branches missed.">        if ((start + size) &gt; occupied.length) {</span>
<span class="nc" id="L279">            throw new SeatAllocationException(&quot;Cannot allocate seats above row capacity&quot;);</span>
        }

        // Now that we know we can allocate the seats, set them to occupied in the allocation matrix
<span class="fc bfc" id="L283" title="All 2 branches covered.">        for (int i = start; i &lt; (start + size); i++) {</span>
<span class="fc" id="L284">            occupied[i] = finalState;</span>
<span class="fc" id="L285">            occupiedCount++;</span>
        }

<span class="fc" id="L288">    }</span>

    /**
     * Dellocate a seat within this section for this performance.
     *
     * @param seat the seats that need to be deallocated
     */
    public void deallocate(Seat seat) {
<span class="pc bpc" id="L296" title="1 of 2 branches missed.">        if (!isAllocated(seat)) {</span>
<span class="nc" id="L297">            throw new SeatAllocationException(&quot;Trying to deallocate an unallocated seat!&quot;);</span>
        }
<span class="fc" id="L299">        this.allocated[seat.getRowNumber()-1][seat.getNumber()-1] = 0;</span>
<span class="fc" id="L300">        occupiedCount --;</span>
<span class="fc" id="L301">    }</span>

    /* Boilerplate getters and setters */

    public int getOccupiedCount() {
<span class="nc" id="L306">        return occupiedCount;</span>
    }

    public Performance getPerformance() {
<span class="nc" id="L310">        return performance;</span>
    }

    public Section getSection() {
<span class="nc" id="L314">        return section;</span>
    }

    public Long getId() {
<span class="nc" id="L318">        return id;</span>
    }

    private long expirationTimestamp() {
<span class="fc" id="L322">        return System.currentTimeMillis() + EXPIRATION_TIME;</span>
    }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.7.202105040129</span></div></body></html>